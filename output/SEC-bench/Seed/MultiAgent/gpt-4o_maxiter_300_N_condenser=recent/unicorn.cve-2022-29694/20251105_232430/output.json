{
  "instance_id": "unicorn.cve-2022-29694",
  "instruction": "\nPlease coordinate the vulnerability reproduction process for the following instance:\n```json\n{\n  \"instance_id\": \"unicorn.cve-2022-29694\",\n  \"repo\": \"unicorn-engine/unicorn\",\n  \"base_commit\": \"cf18982e1c29d354805863a8e017cddd974e3114\",\n  \"work_dir\": \"/src/unicorn\",\n  \"build_sh\": \"#!/bin/bash -eu\\n# Minimized build script with only core build commands\\nset -eu\\nmkdir -p build\\ncd build\\ncmake .. -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=off -DUNICORN_FUZZ=1\\nmake -j4\",\n  \"bug_description\": \"================= Bug Report (1/1) ==================\\n## Source: GitHub Issue\\n## URL: https://github.com/unicorn-engine/unicorn/issues/1588\\n## Description:\\nIssue: unicorn-engine/unicorn#1588\\nTitle: Null pointer dereference in `qemu_ram_free` when HVA malloc fails\\nState: closed\\nCreated by: liyansong2018\\nCreated at: 2022-04-12 12:06:38+00:00\\n\\nIssue Body:\\nWhen we try to use `uc_mem_map` to apply for super large memory, memory allocation in HAV fails, but succeeds  in GVA. This inconsistency leads to null pointer dereference in `us_ close` release about the ram block requested by `uc_mem_map`.\\n\\nPoC\\n```c\\nint main(int argc, char **argv) {\\n    uc_engine *uc;\\n    uc_err err;\\n    err = uc_open(UC_ARCH_X86, UC_MODE_64, &uc);\\n    if (err != UC_ERR_OK) {\\n        printf(\\\"Failed on uc_open() with error returned: %u %s\\\\n\\\", err, uc_strerror(err));\\n        return -1;\\n    }\\n\\n    err = uc_mem_map(uc, 0x0, 0xfffffffff000, UC_PROT_ALL);\\n    if (err != UC_ERR_OK) {\\n        printf(\\\"Failed on uc_open() with error returned: %u %s\\\\n\\\", err, uc_strerror(err));\\n        //return -1;\\n    }\\n    uc_close(uc);\\n    return 0;\\n}\\n```\\n\\noutput\\n```shell\\n$ ./poc_test\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==36945==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7f6f0c61dc5f bp 0x7ffd6adc9320 sp 0x7ffd6adc9310 T0)                                                                                                                   \\n==36945==The signal is caused by a WRITE memory access.                                                                    \\n==36945==Hint: address points to the zero page.\\n    #0 0x7f6f0c61dc5f in qemu_ram_free_x86_64 /home/lys/Documents/my/unicorn/qemu/exec.c:1133\\n    #1 0x7f6f0c624483 in memory_region_destructor_ram /home/lys/Documents/my/unicorn/qemu/softmmu/memory.c:882\\n    #2 0x7f6f0c62269f in memory_free_x86_64 /home/lys/Documents/my/unicorn/qemu/softmmu/memory.c:182\\n    #3 0x7f6f0c6169da in release_common /home/lys/Documents/my/unicorn/qemu/unicorn_common.h:62\\n    #4 0x7f6f0c616cd3 in x86_release /home/lys/Documents/my/unicorn/qemu/target/i386/unicorn.c:47\\n    #5 0x7f6f0c60e4c5 in uc_close /home/lys/Documents/my/unicorn/uc.c:419\\n    #6 0x55955d1423e1 in main /home/lys/Documents/unitest/poc_test.c:60\\n    #7 0x7f6f0c0d47ec in __libc_start_main ../csu/libc-start.c:332\\n    #8 0x55955d142129 in _start (/home/lys/Documents/unitest/poc_test+0x1129)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV /home/lys/Documents/my/unicorn/qemu/exec.c:1133 in qemu_ram_free_x86_64\\n==36945==ABORTING\\n```\\n\\n\\nComments:\\nComment by liyansong2018 on 2022-04-12 12:15:16+00:00:\\nThere are many ways to fix this bug. I will pull request with a simple patch later.\\n\\n---\\n\\nComment by wtdcode on 2022-04-16 17:18:22+00:00:\\nFixed in 3d3deac5e6d38602b689c4fef5dac004f07a2e63\\n\\nCommit References:\\n3d3deac5e6d38602b689c4fef5dac004f07a2e63\",\n  \"candidate_fixes\": [\n    {\n      \"sha\": \"3d3deac5e6d38602b689c4fef5dac004f07a2e63\",\n      \"url\": \"https://github.com/unicorn-engine/unicorn/commit/3d3deac5e6d38602b689c4fef5dac004f07a2e63\"\n    },\n    {\n      \"sha\": \"31389e59457f304be3809f9679f91a42daa7ebaa\",\n      \"url\": null\n    },\n    {\n      \"sha\": \"6a879a082d4d67a5d13f1233ae0334cde0a7f844\",\n      \"url\": null\n    },\n    {\n      \"sha\": \"f7b5b69cb44036fe1bc5f07aae90f8050fe65486\",\n      \"url\": \"https://github.com/unicorn-engine/unicorn/commit/f7b5b69cb44036fe1bc5f07aae90f8050fe65486\"\n    },\n    {\n      \"sha\": \"ae77335a70bdab8adae2ffe06212c17d171e00cb\",\n      \"url\": \"https://github.com/unicorn-engine/unicorn/commit/ae77335a70bdab8adae2ffe06212c17d171e00cb\"\n    },\n    {\n      \"sha\": \"b5ea277900d3f9aeae0ab15aa65c525955540a36\",\n      \"url\": \"https://github.com/unicorn-engine/unicorn/commit/b5ea277900d3f9aeae0ab15aa65c525955540a36\"\n    }\n  ]\n}\n```\nI will delegate to specialized agents sequentially: BuilderAgent, ExploiterAgent, FixerAgent.\nPlease start by delegating to the BuilderAgent.\n",
  "instance": {
    "instance_id": "unicorn.cve-2022-29694",
    "repo": "unicorn-engine/unicorn",
    "base_commit": "cf18982e1c29d354805863a8e017cddd974e3114",
    "work_dir": "/src/unicorn",
    "build_sh": "#!/bin/bash -eu\n# Minimized build script with only core build commands\nset -eu\nmkdir -p build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=off -DUNICORN_FUZZ=1\nmake -j4",
    "bug_description": "================= Bug Report (1/1) ==================\n## Source: GitHub Issue\n## URL: https://github.com/unicorn-engine/unicorn/issues/1588\n## Description:\nIssue: unicorn-engine/unicorn#1588\nTitle: Null pointer dereference in `qemu_ram_free` when HVA malloc fails\nState: closed\nCreated by: liyansong2018\nCreated at: 2022-04-12 12:06:38+00:00\n\nIssue Body:\nWhen we try to use `uc_mem_map` to apply for super large memory, memory allocation in HAV fails, but succeeds  in GVA. This inconsistency leads to null pointer dereference in `us_ close` release about the ram block requested by `uc_mem_map`.\n\nPoC\n```c\nint main(int argc, char **argv) {\n    uc_engine *uc;\n    uc_err err;\n    err = uc_open(UC_ARCH_X86, UC_MODE_64, &uc);\n    if (err != UC_ERR_OK) {\n        printf(\"Failed on uc_open() with error returned: %u %s\\n\", err, uc_strerror(err));\n        return -1;\n    }\n\n    err = uc_mem_map(uc, 0x0, 0xfffffffff000, UC_PROT_ALL);\n    if (err != UC_ERR_OK) {\n        printf(\"Failed on uc_open() with error returned: %u %s\\n\", err, uc_strerror(err));\n        //return -1;\n    }\n    uc_close(uc);\n    return 0;\n}\n```\n\noutput\n```shell\n$ ./poc_test\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==36945==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7f6f0c61dc5f bp 0x7ffd6adc9320 sp 0x7ffd6adc9310 T0)                                                                                                                   \n==36945==The signal is caused by a WRITE memory access.                                                                    \n==36945==Hint: address points to the zero page.\n    #0 0x7f6f0c61dc5f in qemu_ram_free_x86_64 /home/lys/Documents/my/unicorn/qemu/exec.c:1133\n    #1 0x7f6f0c624483 in memory_region_destructor_ram /home/lys/Documents/my/unicorn/qemu/softmmu/memory.c:882\n    #2 0x7f6f0c62269f in memory_free_x86_64 /home/lys/Documents/my/unicorn/qemu/softmmu/memory.c:182\n    #3 0x7f6f0c6169da in release_common /home/lys/Documents/my/unicorn/qemu/unicorn_common.h:62\n    #4 0x7f6f0c616cd3 in x86_release /home/lys/Documents/my/unicorn/qemu/target/i386/unicorn.c:47\n    #5 0x7f6f0c60e4c5 in uc_close /home/lys/Documents/my/unicorn/uc.c:419\n    #6 0x55955d1423e1 in main /home/lys/Documents/unitest/poc_test.c:60\n    #7 0x7f6f0c0d47ec in __libc_start_main ../csu/libc-start.c:332\n    #8 0x55955d142129 in _start (/home/lys/Documents/unitest/poc_test+0x1129)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /home/lys/Documents/my/unicorn/qemu/exec.c:1133 in qemu_ram_free_x86_64\n==36945==ABORTING\n```\n\n\nComments:\nComment by liyansong2018 on 2022-04-12 12:15:16+00:00:\nThere are many ways to fix this bug. I will pull request with a simple patch later.\n\n---\n\nComment by wtdcode on 2022-04-16 17:18:22+00:00:\nFixed in 3d3deac5e6d38602b689c4fef5dac004f07a2e63\n\nCommit References:\n3d3deac5e6d38602b689c4fef5dac004f07a2e63",
    "candidate_fixes": [
      {
        "sha": "3d3deac5e6d38602b689c4fef5dac004f07a2e63",
        "url": "https://github.com/unicorn-engine/unicorn/commit/3d3deac5e6d38602b689c4fef5dac004f07a2e63"
      },
      {
        "sha": "31389e59457f304be3809f9679f91a42daa7ebaa",
        "url": null
      },
      {
        "sha": "6a879a082d4d67a5d13f1233ae0334cde0a7f844",
        "url": null
      },
      {
        "sha": "f7b5b69cb44036fe1bc5f07aae90f8050fe65486",
        "url": "https://github.com/unicorn-engine/unicorn/commit/f7b5b69cb44036fe1bc5f07aae90f8050fe65486"
      },
      {
        "sha": "ae77335a70bdab8adae2ffe06212c17d171e00cb",
        "url": "https://github.com/unicorn-engine/unicorn/commit/ae77335a70bdab8adae2ffe06212c17d171e00cb"
      },
      {
        "sha": "b5ea277900d3f9aeae0ab15aa65c525955540a36",
        "url": "https://github.com/unicorn-engine/unicorn/commit/b5ea277900d3f9aeae0ab15aa65c525955540a36"
      }
    ]
  },
  "result": {
    "execution": {
      "builder": {
        "success": false,
        "command": "cd /src/unicorn && git reset --hard 3d3deac5e6d38602b689c4fef5dac004f07a2e63 && secb build",
        "exit_code": 1,
        "message": "Build failed at base commit (exit code 1):\nHEAD is now at 3d3deac5 Fix crash when mapping a big memory and calling uc_close\nBUILDING THE PROJECT...\nDetected git sub-modules - initialising/updating...\nRepository changes already applied or cannot be applied cleanly. Proceeding with build.\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn file included from /src/unicorn/qemu/tcg/tcg.c:294:\n 1860 |                        const TCGArg args[TCG_MAX_OP_ARGS],\n      |                        ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:110:68: note: previously declared as \u2018const TCGArg *\u2019 {aka \u2018const long unsigned int *\u2019}\n  110 | static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n      |                                                      ~~~~~~~~~~~~~~^~~~\n 1861 |                        const int const_args[TCG_MAX_OP_ARGS])\n      |                        ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/tcg/tcg.c:111:35: note: previously declared as \u2018const int *\u2019\n  111 |                        const int *const_args);\n      |                        ~~~~~~~~~~~^~~~~~~~~~\nIn function \u2018mmu_translate_asce\u2019,\n    inlined from \u2018mmu_translate\u2019 at /src/unicorn/qemu/target/s390x/mmu_helper.c:412:9:\n  125 |     if (asce & ASCE_REAL_SPACE) {\n/src/unicorn/qemu/target/s390x/mmu_helper.c: In function \u2018mmu_translate\u2019:\n/src/unicorn/qemu/target/s390x/mmu_helper.c:364:14: note: \u2018asce\u2019 was declared here\n  364 |     uint64_t asce;\n      |              ^~~~\n  394 | static int sigp_set_architecture(S390CPU *cpu, uint32_t param,\n      |            ^~~~~~~~~~~~~~~~~~~~~\n  324 | static int handle_sigp_single_dst(S390CPU *cpu, S390CPU *dst_cpu, uint8_t order,\n      |            ^~~~~~~~~~~~~~~~~~~~~~\n/src/unicorn/qemu/target/s390x/translate.c: In function \u2018op_risbg\u2019:\n 3949 |         imask = ~pmask;\n      |         ~~~~~~^~~~~~~~\n/src/unicorn/qemu/target/s390x/translate.c:3909:27: note: \u2018pmask\u2019 was declared here\n 3909 |     uint64_t mask, imask, pmask;\n      |                           ^~~~~\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `find_context_reg_rw_function':\n/src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `uc_open':\n/src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: /src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `find_context_reg_rw_function':\n/src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `uc_open':\n/src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: /src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `find_context_reg_rw_function':\n/src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `uc_open':\n/src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: /src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `find_context_reg_rw_function':\n/src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `uc_open':\n/src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: /src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `find_context_reg_rw_function':\n/src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `uc_open':\n/src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: /src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `find_context_reg_rw_function':\n/src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `uc_open':\n/src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: /src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `find_context_reg_rw_function':\n/src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `uc_open':\n/src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: /src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `find_context_reg_rw_function':\n/src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1935: undefined reference to `ppc64_context_reg_read'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: /src/unicorn/uc.c:1936: undefined reference to `ppc64_context_reg_write'\n/usr/bin/ld: libunicorn.a(uc.c.o): in function `uc_open':\n/src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\n/usr/bin/ld: /src/unicorn/uc.c:356: undefined reference to `ppc64_uc_init'\ncollect2: error: ld returned 1 exit status\ncollect2: error: ld returned 1 exit status\nmake[2]: *** [CMakeFiles/sample_arm.dir/build.make:98: sample_arm] Error 1\nmake[1]: *** [CMakeFiles/Makefile2:780: CMakeFiles/sample_arm.dir/all] Error 2\nmake[1]: *** Waiting for unfinished jobs....\ncollect2: error: ld returned 1 exit status\nmake[2]: *** [CMakeFiles/sample_batch_reg.dir/build.make:98: sample_batch_reg] Error 1\nmake[1]: *** [CMakeFiles/Makefile2:702: CMakeFiles/sample_batch_reg.dir/all] Error 2\nmake[2]: *** [CMakeFiles/mem_apis.dir/build.make:98: mem_apis] Error 1\nmake[1]: *** [CMakeFiles/Makefile2:728: CMakeFiles/mem_apis.dir/all] Error 2\ncollect2: error: ld returned 1 exit status\nmake[2]: *** [CMakeFiles/sample_arm64.dir/build.make:98: sample_arm64] Error 1\nmake[1]: *** [CMakeFiles/Makefile2:806: CMakeFiles/sample_arm64.dir/all] Error 2\ncollect2: error: ld returned 1 exit status\nmake[2]: *** [CMakeFiles/sample_x86_32_gdt_and_seg_regs.dir/build.make:98: sample_x86_32_gdt_and_seg_regs] Error 1\nmake[1]: *** [CMakeFiles/Makefile2:676: CMakeFiles/sample_x86_32_gdt_and_seg_regs.dir/all] Error 2\ncollect2: error: ld returned 1 exit status\nmake[2]: *** [CMakeFiles/sample_m68k.dir/build.make:98: sample_m68k] Error 1\nmake[1]: *** [CMakeFiles/Makefile2:832: CMakeFiles/sample_m68k.dir/all] Error 2\ncollect2: error: ld returned 1 exit status\nmake[2]: *** [CMakeFiles/sample_x86.dir/build.make:98: sample_x86] Error 1\nmake[1]: *** [CMakeFiles/Makefile2:650: CMakeFiles/sample_x86.dir/all] Error 2\ncollect2: error: ld returned 1 exit status\nmake[2]: *** [CMakeFiles/shellcode.dir/build.make:98: shellcode] Error 1\nmake[1]: *** [CMakeFiles/Makefile2:754: CMakeFiles/shellcode.dir/all] Error 2\nmake: *** [Makefile:146: all] Error 2\nBUILD FAILED!"
      },
      "exploiter": {
        "success": false,
        "command": "cd /src/unicorn && git reset --hard 3d3deac5e6d38602b689c4fef5dac004f07a2e63 && secb build",
        "exit_code": 1,
        "message": "Skipped due to build failure"
      },
      "fixer": {
        "success": false,
        "command": "",
        "exit_code": -1,
        "message": "Verification not run"
      }
    },
    "build_sh": "#!/bin/bash\n\n# Ensure the script is executed from the correct directory\nif [ \"$(basename $PWD)\" != \"unicorn\" ]; then\n    echo \"Please run this script from the unicorn directory.\"\n    exit 1\nfi\n\n# Create build directory if it doesn't exist\nmkdir -p build\n\n# Navigate to build directory\ncd build\n\n# Configure the project\nif [ -f ../CMakeLists.txt ]; then\n    cmake .. -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=off\nelse\n    echo \"CMakeLists.txt not found in the parent directory.\"\n    exit 1\nfi\n\n# Build the project using all available processors\nmake -j$(nproc)",
    "secb_sh": "#!/bin/bash\nset -euo pipefail\n\nbuild() {\n    echo \"BUILDING THE PROJECT...\"\n\n    # Handle git sub-modules\n    if [[ -f .gitmodules || -f .gitmodule ]]; then\n        echo \"Detected git sub-modules - initialising/updating...\"\n        git submodule update --init --recursive\n    else\n        echo \"No git sub-modules found - skipping update.\"\n    fi\n\n    # Check for repo_changes.diff and apply if it exists and hasn't been applied yet\n    if [[ -f /testcase/repo_changes.diff ]]; then\n        # Check if the patch has already been applied to avoid re-applying\n        if ! git apply --check /testcase/repo_changes.diff &>/dev/null; then\n            echo \"Repository changes already applied or cannot be applied cleanly. Proceeding with build.\"\n        else\n            echo \"Applying repository changes from repo_changes.diff...\"\n            git apply /testcase/repo_changes.diff || echo \"Warning: Could not apply repo_changes.diff cleanly. Proceeding anyway.\"\n        fi\n    fi\n\n    # stdout: /dev/null\n    # stderr: grep filters out \"warning:\" and lets everything else through\n    if /usr/local/bin/compile \\\n         1>/dev/null \\\n         2> >(grep -Fv --line-buffered -e \"warning:\" -e \"SyntaxWarning:\" -e \"WARNING:\" >&2); then\n        echo \"BUILD COMPLETED SUCCESSFULLY!\"\n    else\n        echo \"BUILD FAILED!\"\n        exit 1\n    fi\n}\n\nrepro() {\n    echo \"REPRODUCING THE ISSUE FOR unicorn.cve-2022-29694...\"\n    # TODO: Add commands to trigger the specific vulnerability\n    # For now, it's a placeholder.\n    echo \"PLACEHOLDER: TRIGGER VULNERABILITY HERE.\"\n    # NOTE: YOU SHOULD NOT RETURN/EXIT 0 IN THIS FUNCTION.\n    # Example: /out/fuzzer /testcase/poc_file\n}\n\npatch() {\n    echo \"PATCHING THE PROJECT...\"\n    cd /src/unicorn\n\n    # Check for repo_changes.diff and apply if it exists and hasn't been applied yet\n    if [[ -f /testcase/repo_changes.diff ]]; then\n        # Check if the patch has already been applied to avoid re-applying\n        if ! git apply --check /testcase/repo_changes.diff &>/dev/null; then\n            echo \"Repository changes already applied or cannot be applied cleanly. Proceeding with patch.\"\n        else\n            echo \"Applying repository changes from repo_changes.diff...\"\n            git apply /testcase/repo_changes.diff || echo \"Warning: Could not apply repo_changes.diff cleanly. Proceeding anyway.\"\n        fi\n    fi\n\n    if git apply /testcase/model_patch.diff; then\n        echo \"PATCH APPLIED SUCCESSFULLY!\"\n    else\n        echo \"PATCH APPLICATION FAILED!\"\n        exit 1\n    fi\n}\n\nif [ \"$#\" -ge 1 ]; then\n    command=\"$1\"\n\n    case \"$command\" in\n        build)\n            build \"$@\"\n            ;;\n        repro)\n            repro \"$@\"\n            ;;\n        patch)\n            patch \"$@\"\n            ;;\n        *)\n            echo \"Unknown command: $command\"\n            echo \"Usage: secb [build|repro|patch]\"\n            exit 1\n            ;;\n    esac\nelse\n    echo \"Usage: secb [build|repro|patch]\"\n    exit 1\nfi",
    "artifacts": {
      "packages.txt": "Y21ha2UK",
      "repo_changes.diff": "ZGlmZiAtLWdpdCBhL0NNYWtlTGlzdHMudHh0IGIvQ01ha2VMaXN0cy50eHQKaW5kZXggZDJhYWMxMGUuLmU0MDU0ZDk4IDEwMDY0NAotLS0gYS9DTWFrZUxpc3RzLnR4dAorKysgYi9DTWFrZUxpc3RzLnR4dApAQCAtNDQsNyArNDQsNyBAQCBvcHRpb24oQlVJTERfU0hBUkVEX0xJQlMgIkJ1aWxkIHNoYXJlZCBpbnN0ZWFkIG9mIHN0YXRpYyBsaWJyYXJ5IiAke1BST0pFQ1RfSVNfVAogb3B0aW9uKFVOSUNPUk5fRlVaWiAiRW5hYmxlIGZ1enppbmciIE9GRikKIG9wdGlvbihVTklDT1JOX0JVSUxEX1RFU1RTICJCdWlsZCB1bmljb3JuIHRlc3RzIiAke1BST0pFQ1RfSVNfVE9QX0xFVkVMfSkKIG9wdGlvbihVTklDT1JOX0lOU1RBTEwgIkVuYWJsZSB1bmljb3JuIGluc3RhbGxhdGlvbiIgJHtQUk9KRUNUX0lTX1RPUF9MRVZFTH0pCi1zZXQoVU5JQ09STl9BUkNIICJ4ODY7YXJtO2FhcmNoNjQ7cmlzY3Y7bWlwcztzcGFyYzttNjhrO3BwYztzMzkweCIgQ0FDSEUgU1RSSU5HICJFbmFibGVkIHVuaWNvcm4gYXJjaGl0ZWN0dXJlcyIpCitzZXQoVU5JQ09STl9BUkNIICJ4ODY7YXJtO2FhcmNoNjQ7cmlzY3Y7bWlwcztzcGFyYzttNjhrO3MzOTB4IiBDQUNIRSBTVFJJTkcgIkVuYWJsZWQgdW5pY29ybiBhcmNoaXRlY3R1cmVzIikKIG9wdGlvbihVTklDT1JOX1RSQUNFUiAiVHJhY2UgdW5pY29ybiBleGVjdXRpb24iIE9GRikKIAogZm9yZWFjaChBUkNIX0xPT1AgJHtVTklDT1JOX0FSQ0h9KQpkaWZmIC0tZ2l0IGEvcWVtdS9leGVjLmMgYi9xZW11L2V4ZWMuYwppbmRleCA1OWJlZWZhZi4uNzE5ODk1YTMgMTAwNjQ0Ci0tLSBhL3FlbXUvZXhlYy5jCisrKyBiL3FlbXUvZXhlYy5jCkBAIC00Miw3ICs0Miw3IEBACiAjaW5jbHVkZSAiZXhlYy9yYW1fYWRkci5oIgogCiAjaW5jbHVkZSAicWVtdS9yYW5nZS5oIgotCisjaW5jbHVkZSAicWVtdS9yY3VfcXVldWUuaCIKICNpbmNsdWRlICJ1Y19wcml2LmgiCiAKIHR5cGVkZWYgc3RydWN0IFBoeXNQYWdlRW50cnkgUGh5c1BhZ2VFbnRyeTsKQEAgLTk2Niw3ICs5NjYsNyBAQCBzdGF0aWMgcmFtX2FkZHJfdCBmaW5kX3JhbV9vZmZzZXQoc3RydWN0IHVjX3N0cnVjdCAqdWMsIHJhbV9hZGRyX3Qgc2l6ZSkKIAogICAgIGFzc2VydChzaXplICE9IDApOyAvKiBpdCB3b3VsZCBoYW5kIG91dCBzYW1lIG9mZnNldCBtdWx0aXBsZSB0aW1lcyAqLwogCi0gICAgaWYgKFFMSVNUX0VNUFRZKCZ1Yy0+cmFtX2xpc3QuYmxvY2tzKSkgeworICAgIGlmIChRTElTVF9FTVBUWV9SQ1UoJnVjLT5yYW1fbGlzdC5ibG9ja3MpKSB7CiAgICAgICAgIHJldHVybiAwOwogICAgIH0KIApAQCAtMTA0Myw2ICsxMDQzLDggQEAgc3RhdGljIHZvaWQgcmFtX2Jsb2NrX2FkZChzdHJ1Y3QgdWNfc3RydWN0ICp1YywgUkFNQmxvY2sgKm5ld19ibG9jaykKICAgICAgICAgbmV3X2Jsb2NrLT5ob3N0ID0gcGh5c19tZW1fYWxsb2ModWMsIG5ld19ibG9jay0+bWF4X2xlbmd0aCwKICAgICAgICAgICAgICAgICAmbmV3X2Jsb2NrLT5tci0+YWxpZ24pOwogICAgICAgICBpZiAoIW5ld19ibG9jay0+aG9zdCkgeworICAgICAgICAgICAgLy8gbW1hcCBmYWlscy4KKyAgICAgICAgICAgIHVjLT5pbnZhbGlkX2Vycm9yID0gVUNfRVJSX05PTUVNOwogICAgICAgICAgICAgLy8gZXJyb3Jfc2V0Z19lcnJubyhlcnJwLCBlcnJubywKICAgICAgICAgICAgIC8vICAgICAgICAgImNhbm5vdCBzZXQgdXAgZ3Vlc3QgbWVtb3J5ICclcyciLAogICAgICAgICAgICAgLy8gICAgICAgICBtZW1vcnlfcmVnaW9uX25hbWUobmV3X2Jsb2NrLT5tcikpOwpAQCAtMTA2MiwxMSArMTA2NCwxMSBAQCBzdGF0aWMgdm9pZCByYW1fYmxvY2tfYWRkKHN0cnVjdCB1Y19zdHJ1Y3QgKnVjLCBSQU1CbG9jayAqbmV3X2Jsb2NrKQogICAgICAgICB9CiAgICAgfQogICAgIGlmIChibG9jaykgewotICAgICAgICBRTElTVF9JTlNFUlRfQkVGT1JFKGJsb2NrLCBuZXdfYmxvY2ssIG5leHQpOworICAgICAgICBRTElTVF9JTlNFUlRfQkVGT1JFX1JDVShibG9jaywgbmV3X2Jsb2NrLCBuZXh0KTsKICAgICB9IGVsc2UgaWYgKGxhc3RfYmxvY2spIHsKLSAgICAgICAgUUxJU1RfSU5TRVJUX0FGVEVSKGxhc3RfYmxvY2ssIG5ld19ibG9jaywgbmV4dCk7CisgICAgICAgIFFMSVNUX0lOU0VSVF9BRlRFUl9SQ1UobGFzdF9ibG9jaywgbmV3X2Jsb2NrLCBuZXh0KTsKICAgICB9IGVsc2UgeyAvKiBsaXN0IGlzIGVtcHR5ICovCi0gICAgICAgIFFMSVNUX0lOU0VSVF9IRUFEKCZ1Yy0+cmFtX2xpc3QuYmxvY2tzLCBuZXdfYmxvY2ssIG5leHQpOworICAgICAgICBRTElTVF9JTlNFUlRfSEVBRF9SQ1UoJnVjLT5yYW1fbGlzdC5ibG9ja3MsIG5ld19ibG9jaywgbmV4dCk7CiAgICAgfQogICAgIHVjLT5yYW1fbGlzdC5tcnVfYmxvY2sgPSBOVUxMOwogCkBAIC0xMDk5LDggKzExMDEsMTUgQEAgUkFNQmxvY2sgKnFlbXVfcmFtX2FsbG9jX2Zyb21fcHRyKHN0cnVjdCB1Y19zdHJ1Y3QgKnVjLCByYW1fYWRkcl90IHNpemUsIHZvaWQgKmgKICAgICBpZiAoaG9zdCkgewogICAgICAgICBuZXdfYmxvY2stPmZsYWdzIHw9IFJBTV9QUkVBTExPQzsKICAgICB9CisKKyAgICB1Yy0+aW52YWxpZF9hZGRyID0gVUNfRVJSX09LOwogICAgIHJhbV9ibG9ja19hZGQobXItPnVjLCBuZXdfYmxvY2spOwogCisgICAgaWYgKHVjLT5pbnZhbGlkX2Vycm9yICE9IFVDX0VSUl9PSykgeworICAgICAgICBnX2ZyZWUobmV3X2Jsb2NrKTsKKyAgICAgICAgcmV0dXJuIE5VTEw7CisgICAgfQorCiAgICAgcmV0dXJuIG5ld19ibG9jazsKIH0KIApAQCAtMTEzMCw3ICsxMTM5LDcgQEAgdm9pZCBxZW11X3JhbV9mcmVlKHN0cnVjdCB1Y19zdHJ1Y3QgKnVjLCBSQU1CbG9jayAqYmxvY2spCiAgICAgLy8gICAgcmFtX2Jsb2NrX25vdGlmeV9yZW1vdmUoYmxvY2stPmhvc3QsIGJsb2NrLT5tYXhfbGVuZ3RoKTsKICAgICAvL30KIAotICAgIFFMSVNUX1JFTU9WRShibG9jaywgbmV4dCk7CisgICAgUUxJU1RfUkVNT1ZFX1JDVShibG9jaywgbmV4dCk7CiAgICAgdWMtPnJhbV9saXN0Lm1ydV9ibG9jayA9IE5VTEw7CiAgICAgLyogV3JpdGUgbGlzdCBiZWZvcmUgdmVyc2lvbiAqLwogICAgIC8vc21wX3dtYigpOwpkaWZmIC0tZ2l0IGEvcWVtdS9pbmNsdWRlL3FlbXUvYXRvbWljLmggYi9xZW11L2luY2x1ZGUvcWVtdS9hdG9taWMuaAppbmRleCBiMzU4Yzk1ZS4uZmU3MDljZWYgMTAwNjQ0Ci0tLSBhL3FlbXUvaW5jbHVkZS9xZW11L2F0b21pYy5oCisrKyBiL3FlbXUvaW5jbHVkZS9xZW11L2F0b21pYy5oCkBAIC0xMTUsNiArMTE1LDE5IEBACiAgICAgYXRvbWljX3NldF9fbm9jaGVjayhwdHIsIGkpOyAgICAgICAgICAgICAgICAgICAgICBcCiB9IHdoaWxlKDApCiAKKyNkZWZpbmUgYXRvbWljX3JjdV9yZWFkKHB0cikgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICAoeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICBRRU1VX0JVSUxEX0JVR19PTihzaXplb2YoKnB0cikgPiBBVE9NSUNfUkVHX1NJWkUpOyBcCisgICAgdHlwZW9mX3N0cmlwX3F1YWwoKnB0cikgX3ZhbDsgICAgICAgICAgICAgICAgICAgICBcCisgICAgYXRvbWljX3JjdV9yZWFkX19ub2NoZWNrKHB0ciwgJl92YWwpOyAgICAgICAgICAgICBcCisgICAgX3ZhbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgfSkKKworI2RlZmluZSBhdG9taWNfcmN1X3NldChwdHIsIGkpIGRvIHsgICAgICAgICAgICAgICAgICAgXAorICAgIFFFTVVfQlVJTERfQlVHX09OKHNpemVvZigqcHRyKSA+IEFUT01JQ19SRUdfU0laRSk7IFwKKyAgICBfX2F0b21pY19zdG9yZV9uKHB0ciwgaSwgX19BVE9NSUNfUkVMRUFTRSk7ICAgICAgIFwKK30gd2hpbGUoMCkKKwogLyogQWxsIHRoZSByZW1haW5pbmcgb3BlcmF0aW9ucyBhcmUgZnVsbHkgc2VxdWVudGlhbGx5IGNvbnNpc3RlbnQgKi8KIAogI2RlZmluZSBhdG9taWNfeGNoZ19fbm9jaGVjayhwdHIsIGkpICAgICh7ICAgICAgICAgICAgICAgICAgXApAQCAtMTkyLDYgKzIwNSw0NiBAQAogI2RlZmluZSBhdG9taWNfcmVhZChwdHIpICAgICAgIGF0b21pY19yZWFkX19ub2NoZWNrKHB0cikKICNkZWZpbmUgYXRvbWljX3NldChwdHIsIGkpICAgICBhdG9taWNfc2V0X19ub2NoZWNrKHB0cixpKQogCisvKioKKyAqIGF0b21pY19yY3VfcmVhZCAtIHJlYWRzIGEgUkNVLXByb3RlY3RlZCBwb2ludGVyIHRvIGEgbG9jYWwgdmFyaWFibGUKKyAqIGludG8gYSBSQ1UgcmVhZC1zaWRlIGNyaXRpY2FsIHNlY3Rpb24uIFRoZSBwb2ludGVyIGNhbiBsYXRlciBiZSBzYWZlbHkKKyAqIGRlcmVmZXJlbmNlZCB3aXRoaW4gdGhlIGNyaXRpY2FsIHNlY3Rpb24uCisgKgorICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHBvaW50ZXIgY29weSBpcyBpbnZhcmlhbnQgdGhvcm91Z2ggdGhlIHdob2xlIGNyaXRpY2FsCisgKiBzZWN0aW9uLgorICoKKyAqIEluc2VydHMgbWVtb3J5IGJhcnJpZXJzIG9uIGFyY2hpdGVjdHVyZXMgdGhhdCByZXF1aXJlIHRoZW0gKGN1cnJlbnRseSBvbmx5CisgKiBBbHBoYSkgYW5kIGRvY3VtZW50cyB3aGljaCBwb2ludGVycyBhcmUgcHJvdGVjdGVkIGJ5IFJDVS4KKyAqCisgKiBhdG9taWNfcmN1X3JlYWQgYWxzbyBpbmNsdWRlcyBhIGNvbXBpbGVyIGJhcnJpZXIgdG8gZW5zdXJlIHRoYXQKKyAqIHZhbHVlLXNwZWN1bGF0aXZlIG9wdGltaXphdGlvbnMgKGUuZy4gVlNTOiBWYWx1ZSBTcGVjdWxhdGlvbgorICogU2NoZWR1bGluZykgZG9lcyBub3QgcGVyZm9ybSB0aGUgZGF0YSByZWFkIGJlZm9yZSB0aGUgcG9pbnRlciByZWFkCisgKiBieSBzcGVjdWxhdGluZyB0aGUgdmFsdWUgb2YgdGhlIHBvaW50ZXIuCisgKgorICogU2hvdWxkIG1hdGNoIGF0b21pY19yY3Vfc2V0KCksIGF0b21pY194Y2hnKCksIGF0b21pY19jbXB4Y2hnKCkuCisgKi8KKyNkZWZpbmUgYXRvbWljX3JjdV9yZWFkKHB0cikgICAgKHsgICAgICAgICAgICAgICAgXAorICAgIHR5cGVvZigqcHRyKSBfdmFsID0gYXRvbWljX3JlYWQocHRyKTsgICAgICAgICBcCisgICAgc21wX3JlYWRfYmFycmllcl9kZXBlbmRzKCk7ICAgICAgICAgICAgICAgICAgIFwKKyAgICBfdmFsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorfSkKKworLyoqCisgKiBhdG9taWNfcmN1X3NldCAtIGFzc2lnbnMgKHB1YmxpY2l6ZXMpIGEgcG9pbnRlciB0byBhIG5ldyBkYXRhIHN0cnVjdHVyZQorICogbWVhbnQgdG8gYmUgcmVhZCBieSBSQ1UgcmVhZC1zaWRlIGNyaXRpY2FsIHNlY3Rpb25zLgorICoKKyAqIERvY3VtZW50cyB3aGljaCBwb2ludGVycyB3aWxsIGJlIGRlcmVmZXJlbmNlZCBieSBSQ1UgcmVhZC1zaWRlIGNyaXRpY2FsCisgKiBzZWN0aW9ucyBhbmQgYWRkcyB0aGUgcmVxdWlyZWQgbWVtb3J5IGJhcnJpZXJzIG9uIGFyY2hpdGVjdHVyZXMgcmVxdWlyaW5nCisgKiB0aGVtLiBJdCBhbHNvIG1ha2VzIHN1cmUgdGhlIGNvbXBpbGVyIGRvZXMgbm90IHJlb3JkZXIgY29kZSBpbml0aWFsaXppbmcgdGhlCisgKiBkYXRhIHN0cnVjdHVyZSBiZWZvcmUgaXRzIHB1YmxpY2F0aW9uLgorICoKKyAqIFNob3VsZCBtYXRjaCBhdG9taWNfcmN1X3JlYWQoKS4KKyAqLworI2RlZmluZSBhdG9taWNfcmN1X3NldChwdHIsIGkpICBkbyB7ICAgICAgICAgICAgICBcCisgICAgc21wX3dtYigpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICBhdG9taWNfc2V0KHB0ciwgaSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorfSB3aGlsZSAoMCkKKwogI2RlZmluZSBhdG9taWNfeGNoZ19fbm9jaGVjayAgYXRvbWljX3hjaGcKIAogLyogUHJvdmlkZSBzaG9ydGVyIG5hbWVzIGZvciBHQ0MgYXRvbWljIGJ1aWx0aW5zLiAgKi8KZGlmZiAtLWdpdCBhL3FlbXUvaW5jbHVkZS9xZW11L3JjdV9xdWV1ZS5oIGIvcWVtdS9pbmNsdWRlL3FlbXUvcmN1X3F1ZXVlLmgKbmV3IGZpbGUgbW9kZSAxMDA2NDQKaW5kZXggMDAwMDAwMDAuLjJkMzg2ZjMwCi0tLSAvZGV2L251bGwKKysrIGIvcWVtdS9pbmNsdWRlL3FlbXUvcmN1X3F1ZXVlLmgKQEAgLTAsMCArMSwyNjggQEAKKyNpZm5kZWYgUUVNVV9SQ1VfUVVFVUVfSAorI2RlZmluZSBRRU1VX1JDVV9RVUVVRV9ICisKKy8qCisgKiByY3VfcXVldWUuaAorICoKKyAqIFJDVS1mcmllbmRseSB2ZXJzaW9ucyBvZiB0aGUgcXVldWUuaCBwcmltaXRpdmVzLgorICoKKyAqIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IKKyAqIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMKKyAqIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlcgorICogdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uCisgKgorICogVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsCisgKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZgorICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUKKyAqIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuCisgKgorICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYworICogTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZQorICogRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQQorICoKKyAqIENvcHlyaWdodCAoYykgMjAxMyBNaWtlIEQuIERheSwgSUJNIENvcnBvcmF0aW9uLgorICoKKyAqIElCTSdzIGNvbnRyaWJ1dGlvbnMgdG8gdGhpcyBmaWxlIG1heSBiZSByZWxpY2Vuc2VkIHVuZGVyIExHUEx2MiBvciBsYXRlci4KKyAqLworCisjaW5jbHVkZSAicWVtdS9xdWV1ZS5oIgorI2luY2x1ZGUgInFlbXUvYXRvbWljLmgiCisKKyNpZmRlZiBfX2NwbHVzcGx1cworZXh0ZXJuICJDIiB7CisjZW5kaWYKKworCisvKgorICogTGlzdCBhY2Nlc3MgbWV0aG9kcy4KKyAqLworI2RlZmluZSBRTElTVF9FTVBUWV9SQ1UoaGVhZCkgKGF0b21pY19yZWFkKCYoaGVhZCktPmxoX2ZpcnN0KSA9PSBOVUxMKQorI2RlZmluZSBRTElTVF9GSVJTVF9SQ1UoaGVhZCkgKGF0b21pY19yY3VfcmVhZCgmKGhlYWQpLT5saF9maXJzdCkpCisjZGVmaW5lIFFMSVNUX05FWFRfUkNVKGVsbSwgZmllbGQpIChhdG9taWNfcmN1X3JlYWQoJihlbG0pLT5maWVsZC5sZV9uZXh0KSkKKworLyoKKyAqIExpc3QgZnVuY3Rpb25zLgorICovCisKKworLyoKKyAqICBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGF0b21pY19yZWFkL3NldCBhbmQgYXRvbWljX3JjdV9yZWFkL3NldAorICogIGlzIGluIHRoZSBpbmNsdWRpbmcgb2YgYSByZWFkL3dyaXRlIG1lbW9yeSBiYXJyaWVyIHRvIHRoZSB2b2xhdGlsZQorICogIGFjY2Vzcy4gYXRvbWljX3JjdV8qIG1hY3JvcyBpbmNsdWRlIHRoZSBtZW1vcnkgYmFycmllciwgdGhlCisgKiAgcGxhaW4gYXRvbWljIG1hY3JvcyBkbyBub3QuIFRoZXJlZm9yZSwgaXQgc2hvdWxkIGJlIGNvcnJlY3QgdG8KKyAqICBpc3N1ZSBhIHNlcmllcyBvZiByZWFkcyBvciB3cml0ZXMgdG8gdGhlIHNhbWUgZWxlbWVudCB1c2luZyBvbmx5CisgKiAgdGhlIGF0b21pY18qIG1hY3JvLCB1bnRpbCB0aGUgbGFzdCByZWFkIG9yIHdyaXRlLCB3aGljaCBzaG91bGQgYmUKKyAqICBhdG9taWNfcmN1XyogdG8gaW50cm9kdWNlIGEgcmVhZCBvciB3cml0ZSBtZW1vcnkgYmFycmllciBhcworICogIGFwcHJvcHJpYXRlLgorICovCisKKy8qIFVwb24gcHVibGljYXRpb24gb2YgdGhlIGxpc3RlbG0tPm5leHQgdmFsdWUsIGxpc3QgcmVhZGVycworICogd2lsbCBzZWUgdGhlIG5ldyBub2RlIHdoZW4gZm9sbG93aW5nIG5leHQgcG9pbnRlcnMgZnJvbQorICogYW50ZWNlZGVudCBub2RlcywgYnV0IG1heSBub3Qgc2VlIHRoZSBuZXcgbm9kZSB3aGVuIGZvbGxvd2luZworICogcHJldiBwb2ludGVycyBmcm9tIHN1YnNlcXVlbnQgbm9kZXMgdW50aWwgYWZ0ZXIgdGhlIFJDVSBncmFjZQorICogcGVyaW9kIGV4cGlyZXMuCisgKiBzZWUgbGludXgvaW5jbHVkZS9yY3VsaXN0LmggX19saXN0X2FkZF9yY3UobmV3LCBwcmV2LCBuZXh0KQorICovCisjZGVmaW5lIFFMSVNUX0lOU0VSVF9BRlRFUl9SQ1UobGlzdGVsbSwgZWxtLCBmaWVsZCkgZG8geyAgICBcCisgICAgKGVsbSktPmZpZWxkLmxlX25leHQgPSAobGlzdGVsbSktPmZpZWxkLmxlX25leHQ7ICAgICAgICBcCisgICAgKGVsbSktPmZpZWxkLmxlX3ByZXYgPSAmKGxpc3RlbG0pLT5maWVsZC5sZV9uZXh0OyAgICAgICBcCisgICAgYXRvbWljX3JjdV9zZXQoJihsaXN0ZWxtKS0+ZmllbGQubGVfbmV4dCwgKGVsbSkpOyAgICAgICBcCisgICAgaWYgKChlbG0pLT5maWVsZC5sZV9uZXh0ICE9IE5VTEwpIHsgICAgICAgICAgICAgICAgICAgICBcCisgICAgICAgKGVsbSktPmZpZWxkLmxlX25leHQtPmZpZWxkLmxlX3ByZXYgPSAgICAgICAgICAgICAgICBcCisgICAgICAgICYoZWxtKS0+ZmllbGQubGVfbmV4dDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCit9IHdoaWxlICgvKkNPTlNUQ09ORCovMCkKKworLyogVXBvbiBwdWJsaWNhdGlvbiBvZiB0aGUgbGlzdGVsbS0+cHJldi0+bmV4dCB2YWx1ZSwgbGlzdAorICogcmVhZGVycyB3aWxsIHNlZSB0aGUgbmV3IGVsZW1lbnQgd2hlbiBmb2xsb3dpbmcgcHJldiBwb2ludGVycworICogZnJvbSBzdWJzZXF1ZW50IGVsZW1lbnRzLCBidXQgbWF5IG5vdCBzZWUgdGhlIG5ldyBlbGVtZW50CisgKiB3aGVuIGZvbGxvd2luZyBuZXh0IHBvaW50ZXJzIGZyb20gYW50ZWNlZGVudCBlbGVtZW50cworICogdW50aWwgYWZ0ZXIgdGhlIFJDVSBncmFjZSBwZXJpb2QgZXhwaXJlcy4KKyAqLworI2RlZmluZSBRTElTVF9JTlNFUlRfQkVGT1JFX1JDVShsaXN0ZWxtLCBlbG0sIGZpZWxkKSBkbyB7ICAgXAorICAgIChlbG0pLT5maWVsZC5sZV9wcmV2ID0gKGxpc3RlbG0pLT5maWVsZC5sZV9wcmV2OyAgICAgICAgXAorICAgIChlbG0pLT5maWVsZC5sZV9uZXh0ID0gKGxpc3RlbG0pOyAgICAgICAgICAgICAgICAgICAgICAgXAorICAgIGF0b21pY19yY3Vfc2V0KChsaXN0ZWxtKS0+ZmllbGQubGVfcHJldiwgKGVsbSkpOyAgICAgICAgXAorICAgIChsaXN0ZWxtKS0+ZmllbGQubGVfcHJldiA9ICYoZWxtKS0+ZmllbGQubGVfbmV4dDsgICAgICAgXAorfSB3aGlsZSAoLypDT05TVENPTkQqLzApCisKKy8qIFVwb24gcHVibGljYXRpb24gb2YgdGhlIGhlYWQtPmZpcnN0IHZhbHVlLCBsaXN0IHJlYWRlcnMKKyAqIHdpbGwgc2VlIHRoZSBuZXcgZWxlbWVudCB3aGVuIGZvbGxvd2luZyB0aGUgaGVhZCwgYnV0IG1heQorICogbm90IHNlZSB0aGUgbmV3IGVsZW1lbnQgd2hlbiBmb2xsb3dpbmcgcHJldiBwb2ludGVycyBmcm9tCisgKiBzdWJzZXF1ZW50IGVsZW1lbnRzIHVudGlsIGFmdGVyIHRoZSBSQ1UgZ3JhY2UgcGVyaW9kIGhhcworICogZXhwaXJlZC4KKyAqLworI2RlZmluZSBRTElTVF9JTlNFUlRfSEVBRF9SQ1UoaGVhZCwgZWxtLCBmaWVsZCkgZG8geyAgICBcCisgICAgKGVsbSktPmZpZWxkLmxlX3ByZXYgPSAmKGhlYWQpLT5saF9maXJzdDsgICAgICAgICAgIFwKKyAgICAoZWxtKS0+ZmllbGQubGVfbmV4dCA9IChoZWFkKS0+bGhfZmlyc3Q7ICAgICAgICAgICAgXAorICAgIGF0b21pY19yY3Vfc2V0KCgmKGhlYWQpLT5saF9maXJzdCksIChlbG0pKTsgICAgICAgICBcCisgICAgaWYgKChlbG0pLT5maWVsZC5sZV9uZXh0ICE9IE5VTEwpIHsgICAgICAgICAgICAgICAgIFwKKyAgICAgICAoZWxtKS0+ZmllbGQubGVfbmV4dC0+ZmllbGQubGVfcHJldiA9ICAgICAgICAgICAgXAorICAgICAgICAmKGVsbSktPmZpZWxkLmxlX25leHQ7ICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKK30gd2hpbGUgKC8qQ09OU1RDT05EKi8wKQorCisKKy8qIHByaW9yIHRvIHB1YmxpY2F0aW9uIG9mIHRoZSBlbG0tPnByZXYtPm5leHQgdmFsdWUsIHNvbWUgbGlzdAorICogcmVhZGVycyBtYXkgc3RpbGwgc2VlIHRoZSByZW1vdmVkIGVsZW1lbnQgd2hlbiBmb2xsb3dpbmcKKyAqIHRoZSBhbnRlY2VkZW50J3MgbmV4dCBwb2ludGVyLgorICovCisjZGVmaW5lIFFMSVNUX1JFTU9WRV9SQ1UoZWxtLCBmaWVsZCkgZG8geyAgICAgICAgICAgXAorICAgIGlmICgoZWxtKS0+ZmllbGQubGVfbmV4dCAhPSBOVUxMKSB7ICAgICAgICAgICAgIFwKKyAgICAgICAoZWxtKS0+ZmllbGQubGVfbmV4dC0+ZmllbGQubGVfcHJldiA9ICAgICAgICBcCisgICAgICAgIChlbG0pLT5maWVsZC5sZV9wcmV2OyAgICAgICAgICAgICAgICAgICAgICAgXAorICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICBhdG9taWNfc2V0KChlbG0pLT5maWVsZC5sZV9wcmV2LCAoZWxtKS0+ZmllbGQubGVfbmV4dCk7IFwKK30gd2hpbGUgKC8qQ09OU1RDT05EKi8wKQorCisvKiBMaXN0IHRyYXZlcnNhbCBtdXN0IG9jY3VyIHdpdGhpbiBhbiBSQ1UgY3JpdGljYWwgc2VjdGlvbi4gICovCisjZGVmaW5lIFFMSVNUX0ZPUkVBQ0hfUkNVKHZhciwgaGVhZCwgZmllbGQpICAgICAgICAgICAgICAgICBcCisgICAgICAgIGZvciAoKHZhcikgPSBhdG9taWNfcmN1X3JlYWQoJihoZWFkKS0+bGhfZmlyc3QpOyAgICBcCisgICAgICAgICAgICAgICAgKHZhcik7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgICAgICAgICAgICAgKHZhcikgPSBhdG9taWNfcmN1X3JlYWQoJih2YXIpLT5maWVsZC5sZV9uZXh0KSkKKworLyogTGlzdCB0cmF2ZXJzYWwgbXVzdCBvY2N1ciB3aXRoaW4gYW4gUkNVIGNyaXRpY2FsIHNlY3Rpb24uICAqLworI2RlZmluZSBRTElTVF9GT1JFQUNIX1NBRkVfUkNVKHZhciwgaGVhZCwgZmllbGQsIG5leHRfdmFyKSAgICAgICAgICAgXAorICAgIGZvciAoKHZhcikgPSAoYXRvbWljX3JjdV9yZWFkKCYoaGVhZCktPmxoX2ZpcnN0KSk7ICAgICAgICAgICAgICAgXAorICAgICAgKHZhcikgJiYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgICAgICAgICgobmV4dF92YXIpID0gYXRvbWljX3JjdV9yZWFkKCYodmFyKS0+ZmllbGQubGVfbmV4dCksIDEpOyAgXAorICAgICAgICAgICAodmFyKSA9IChuZXh0X3ZhcikpCisKKy8qCisgKiBSQ1Ugc2ltcGxlIHF1ZXVlCisgKi8KKworLyogU2ltcGxlIHF1ZXVlIGFjY2VzcyBtZXRob2RzICovCisjZGVmaW5lIFFTSU1QTEVRX0VNUFRZX1JDVShoZWFkKSAgICAgIChhdG9taWNfcmVhZCgmKGhlYWQpLT5zcWhfZmlyc3QpID09IE5VTEwpCisjZGVmaW5lIFFTSU1QTEVRX0ZJUlNUX1JDVShoZWFkKSAgICAgICBhdG9taWNfcmN1X3JlYWQoJihoZWFkKS0+c3FoX2ZpcnN0KQorI2RlZmluZSBRU0lNUExFUV9ORVhUX1JDVShlbG0sIGZpZWxkKSAgYXRvbWljX3JjdV9yZWFkKCYoZWxtKS0+ZmllbGQuc3FlX25leHQpCisKKy8qIFNpbXBsZSBxdWV1ZSBmdW5jdGlvbnMgKi8KKyNkZWZpbmUgUVNJTVBMRVFfSU5TRVJUX0hFQURfUkNVKGhlYWQsIGVsbSwgZmllbGQpIGRvIHsgICAgICAgICBcCisgICAgKGVsbSktPmZpZWxkLnNxZV9uZXh0ID0gKGhlYWQpLT5zcWhfZmlyc3Q7ICAgICAgICAgICAgICAgICAgXAorICAgIGlmICgoZWxtKS0+ZmllbGQuc3FlX25leHQgPT0gTlVMTCkgeyAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICAgICAgKGhlYWQpLT5zcWhfbGFzdCA9ICYoZWxtKS0+ZmllbGQuc3FlX25leHQ7ICAgICAgICAgICAgICBcCisgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgIGF0b21pY19yY3Vfc2V0KCYoaGVhZCktPnNxaF9maXJzdCwgKGVsbSkpOyAgICAgICAgICAgICAgICAgIFwKK30gd2hpbGUgKC8qQ09OU1RDT05EKi8wKQorCisjZGVmaW5lIFFTSU1QTEVRX0lOU0VSVF9UQUlMX1JDVShoZWFkLCBlbG0sIGZpZWxkKSBkbyB7ICAgIFwKKyAgICAoZWxtKS0+ZmllbGQuc3FlX25leHQgPSBOVUxMOyAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgIGF0b21pY19yY3Vfc2V0KChoZWFkKS0+c3FoX2xhc3QsIChlbG0pKTsgICAgICAgICAgICAgICBcCisgICAgKGhlYWQpLT5zcWhfbGFzdCA9ICYoZWxtKS0+ZmllbGQuc3FlX25leHQ7ICAgICAgICAgICAgIFwKK30gd2hpbGUgKC8qQ09OU1RDT05EKi8wKQorCisjZGVmaW5lIFFTSU1QTEVRX0lOU0VSVF9BRlRFUl9SQ1UoaGVhZCwgbGlzdGVsbSwgZWxtLCBmaWVsZCkgZG8geyAgICAgICBcCisgICAgKGVsbSktPmZpZWxkLnNxZV9uZXh0ID0gKGxpc3RlbG0pLT5maWVsZC5zcWVfbmV4dDsgICAgICAgICAgICAgICAgICBcCisgICAgaWYgKChlbG0pLT5maWVsZC5zcWVfbmV4dCA9PSBOVUxMKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgICAgIChoZWFkKS0+c3FoX2xhc3QgPSAmKGVsbSktPmZpZWxkLnNxZV9uZXh0OyAgICAgICAgICAgICAgICAgICAgICBcCisgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgYXRvbWljX3JjdV9zZXQoJihsaXN0ZWxtKS0+ZmllbGQuc3FlX25leHQsIChlbG0pKTsgICAgICAgICAgICAgICAgICBcCit9IHdoaWxlICgvKkNPTlNUQ09ORCovMCkKKworI2RlZmluZSBRU0lNUExFUV9SRU1PVkVfSEVBRF9SQ1UoaGVhZCwgZmllbGQpIGRvIHsgICAgICAgICAgICAgICAgICAgICBcCisgICAgYXRvbWljX3NldCgmKGhlYWQpLT5zcWhfZmlyc3QsIChoZWFkKS0+c3FoX2ZpcnN0LT5maWVsZC5zcWVfbmV4dCk7IFwKKyAgICBpZiAoKGhlYWQpLT5zcWhfZmlyc3QgPT0gTlVMTCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgICAgICAoaGVhZCktPnNxaF9sYXN0ID0gJihoZWFkKS0+c3FoX2ZpcnN0OyAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKK30gd2hpbGUgKC8qQ09OU1RDT05EKi8wKQorCisjZGVmaW5lIFFTSU1QTEVRX1JFTU9WRV9SQ1UoaGVhZCwgZWxtLCB0eXBlLCBmaWVsZCkgZG8geyAgICAgICAgICAgIFwKKyAgICBpZiAoKGhlYWQpLT5zcWhfZmlyc3QgPT0gKGVsbSkpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgICAgICBRU0lNUExFUV9SRU1PVkVfSEVBRF9SQ1UoKGhlYWQpLCBmaWVsZCk7ICAgICAgICAgICAgICAgICAgICBcCisgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICAgICAgc3RydWN0IHR5cGUgKmN1cnIgPSAoaGVhZCktPnNxaF9maXJzdDsgICAgICAgICAgICAgICAgICAgICAgXAorICAgICAgICB3aGlsZSAoY3Vyci0+ZmllbGQuc3FlX25leHQgIT0gKGVsbSkpIHsgICAgICAgICAgICAgICAgICAgICBcCisgICAgICAgICAgICBjdXJyID0gY3Vyci0+ZmllbGQuc3FlX25leHQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgICAgICBhdG9taWNfc2V0KCZjdXJyLT5maWVsZC5zcWVfbmV4dCwgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgICAgICAgICAgICAgICAgY3Vyci0+ZmllbGQuc3FlX25leHQtPmZpZWxkLnNxZV9uZXh0KTsgICAgICAgICAgIFwKKyAgICAgICAgaWYgKGN1cnItPmZpZWxkLnNxZV9uZXh0ID09IE5VTEwpIHsgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgICAgICAgICAgKGhlYWQpLT5zcWhfbGFzdCA9ICYoY3VyciktPmZpZWxkLnNxZV9uZXh0OyAgICAgICAgICAgICBcCisgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorfSB3aGlsZSAoLypDT05TVENPTkQqLzApCisKKyNkZWZpbmUgUVNJTVBMRVFfRk9SRUFDSF9SQ1UodmFyLCBoZWFkLCBmaWVsZCkgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICBmb3IgKCh2YXIpID0gYXRvbWljX3JjdV9yZWFkKCYoaGVhZCktPnNxaF9maXJzdCk7ICAgICAgICAgICAgICAgICAgIFwKKyAgICAgICAgICh2YXIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICAgICAgICh2YXIpID0gYXRvbWljX3JjdV9yZWFkKCYodmFyKS0+ZmllbGQuc3FlX25leHQpKQorCisjZGVmaW5lIFFTSU1QTEVRX0ZPUkVBQ0hfU0FGRV9SQ1UodmFyLCBoZWFkLCBmaWVsZCwgbmV4dCkgICAgICAgICAgICAgICAgXAorICAgIGZvciAoKHZhcikgPSBhdG9taWNfcmN1X3JlYWQoJihoZWFkKS0+c3FoX2ZpcnN0KTsgICAgICAgICAgICAgICAgICAgIFwKKyAgICAgICAgICh2YXIpICYmICgobmV4dCkgPSBhdG9taWNfcmN1X3JlYWQoJih2YXIpLT5maWVsZC5zcWVfbmV4dCksIDEpOyBcCisgICAgICAgICAodmFyKSA9IChuZXh0KSkKKworLyoKKyAqIFJDVSB0YWlsIHF1ZXVlCisgKi8KKworLyogVGFpbCBxdWV1ZSBhY2Nlc3MgbWV0aG9kcyAqLworI2RlZmluZSBRVEFJTFFfRU1QVFlfUkNVKGhlYWQpICAgICAgKGF0b21pY19yZWFkKCYoaGVhZCktPnRxaF9maXJzdCkgPT0gTlVMTCkKKyNkZWZpbmUgUVRBSUxRX0ZJUlNUX1JDVShoZWFkKSAgICAgICBhdG9taWNfcmN1X3JlYWQoJihoZWFkKS0+dHFoX2ZpcnN0KQorI2RlZmluZSBRVEFJTFFfTkVYVF9SQ1UoZWxtLCBmaWVsZCkgIGF0b21pY19yY3VfcmVhZCgmKGVsbSktPmZpZWxkLnRxZV9uZXh0KQorCisvKiBUYWlsIHF1ZXVlIGZ1bmN0aW9ucyAqLworI2RlZmluZSBRVEFJTFFfSU5TRVJUX0hFQURfUkNVKGhlYWQsIGVsbSwgZmllbGQpIGRvIHsgICAgICAgICAgICAgICAgICAgXAorICAgIChlbG0pLT5maWVsZC50cWVfbmV4dCA9IChoZWFkKS0+dHFoX2ZpcnN0OyAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgIGlmICgoZWxtKS0+ZmllbGQudHFlX25leHQgIT0gTlVMTCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgICAgICAoaGVhZCktPnRxaF9maXJzdC0+ZmllbGQudHFlX2NpcmMudHFsX3ByZXYgPSAgICAgICAgICAgICAgICAgICAgXAorICAgICAgICAgICAgJihlbG0pLT5maWVsZC50cWVfY2lyYzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgICAgICAoaGVhZCktPnRxaF9jaXJjLnRxbF9wcmV2ID0gJihlbG0pLT5maWVsZC50cWVfY2lyYzsgICAgICAgICAgICAgXAorICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgIGF0b21pY19yY3Vfc2V0KCYoaGVhZCktPnRxaF9maXJzdCwgKGVsbSkpOyAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgIChlbG0pLT5maWVsZC50cWVfY2lyYy50cWxfcHJldiA9ICYoaGVhZCktPnRxaF9jaXJjOyAgICAgICAgICAgICAgICAgXAorfSB3aGlsZSAoLypDT05TVENPTkQqLzApCisKKyNkZWZpbmUgUVRBSUxRX0lOU0VSVF9UQUlMX1JDVShoZWFkLCBlbG0sIGZpZWxkKSBkbyB7ICAgICAgICAgICAgICAgICAgIFwKKyAgICAoZWxtKS0+ZmllbGQudHFlX25leHQgPSBOVUxMOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICAoZWxtKS0+ZmllbGQudHFlX2NpcmMudHFsX3ByZXYgPSAoaGVhZCktPnRxaF9jaXJjLnRxbF9wcmV2OyAgICAgICAgIFwKKyAgICBhdG9taWNfcmN1X3NldCgmKGhlYWQpLT50cWhfY2lyYy50cWxfcHJldi0+dHFsX25leHQsIChlbG0pKTsgICAgICAgIFwKKyAgICAoaGVhZCktPnRxaF9jaXJjLnRxbF9wcmV2ID0gJihlbG0pLT5maWVsZC50cWVfY2lyYzsgICAgICAgICAgICAgICAgIFwKK30gd2hpbGUgKC8qQ09OU1RDT05EKi8wKQorCisjZGVmaW5lIFFUQUlMUV9JTlNFUlRfQUZURVJfUkNVKGhlYWQsIGxpc3RlbG0sIGVsbSwgZmllbGQpIGRvIHsgICAgICAgICBcCisgICAgKGVsbSktPmZpZWxkLnRxZV9uZXh0ID0gKGxpc3RlbG0pLT5maWVsZC50cWVfbmV4dDsgICAgICAgICAgICAgICAgICBcCisgICAgaWYgKChlbG0pLT5maWVsZC50cWVfbmV4dCAhPSBOVUxMKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgICAgIChlbG0pLT5maWVsZC50cWVfbmV4dC0+ZmllbGQudHFlX2NpcmMudHFsX3ByZXYgPSAgICAgICAgICAgICAgICBcCisgICAgICAgICAgICAmKGVsbSktPmZpZWxkLnRxZV9jaXJjOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgICAgIChoZWFkKS0+dHFoX2NpcmMudHFsX3ByZXYgPSAmKGVsbSktPmZpZWxkLnRxZV9jaXJjOyAgICAgICAgICAgICBcCisgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgYXRvbWljX3JjdV9zZXQoJihsaXN0ZWxtKS0+ZmllbGQudHFlX25leHQsIChlbG0pKTsgICAgICAgICAgICAgICAgICBcCisgICAgKGVsbSktPmZpZWxkLnRxZV9jaXJjLnRxbF9wcmV2ID0gJihsaXN0ZWxtKS0+ZmllbGQudHFlX2NpcmM7ICAgICAgICBcCit9IHdoaWxlICgvKkNPTlNUQ09ORCovMCkKKworI2RlZmluZSBRVEFJTFFfSU5TRVJUX0JFRk9SRV9SQ1UobGlzdGVsbSwgZWxtLCBmaWVsZCkgZG8geyAgICAgICAgICAgICAgICBcCisgICAgKGVsbSktPmZpZWxkLnRxZV9jaXJjLnRxbF9wcmV2ID0gKGxpc3RlbG0pLT5maWVsZC50cWVfY2lyYy50cWxfcHJldjsgIFwKKyAgICAoZWxtKS0+ZmllbGQudHFlX25leHQgPSAobGlzdGVsbSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorICAgIGF0b21pY19yY3Vfc2V0KCYobGlzdGVsbSktPmZpZWxkLnRxZV9jaXJjLnRxbF9wcmV2LT50cWxfbmV4dCwgKGVsbSkpOyBcCisgICAgKGxpc3RlbG0pLT5maWVsZC50cWVfY2lyYy50cWxfcHJldiA9ICYoZWxtKS0+ZmllbGQudHFlX2NpcmM7ICAgICAgICAgIFwKK30gd2hpbGUgKC8qQ09OU1RDT05EKi8wKQorCisjZGVmaW5lIFFUQUlMUV9SRU1PVkVfUkNVKGhlYWQsIGVsbSwgZmllbGQpIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgaWYgKCgoZWxtKS0+ZmllbGQudHFlX25leHQpICE9IE5VTEwpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgICAgIChlbG0pLT5maWVsZC50cWVfbmV4dC0+ZmllbGQudHFlX2NpcmMudHFsX3ByZXYgPSAgICAgICAgICAgICAgICBcCisgICAgICAgICAgICAoZWxtKS0+ZmllbGQudHFlX2NpcmMudHFsX3ByZXY7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgICAgIChoZWFkKS0+dHFoX2NpcmMudHFsX3ByZXYgPSAoZWxtKS0+ZmllbGQudHFlX2NpcmMudHFsX3ByZXY7ICAgICBcCisgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcCisgICAgYXRvbWljX3NldCgmKGVsbSktPmZpZWxkLnRxZV9jaXJjLnRxbF9wcmV2LT50cWxfbmV4dCwgKGVsbSktPmZpZWxkLnRxZV9uZXh0KTsgXAorICAgIChlbG0pLT5maWVsZC50cWVfY2lyYy50cWxfcHJldiA9IE5VTEw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXAorfSB3aGlsZSAoLypDT05TVENPTkQqLzApCisKKyNkZWZpbmUgUVRBSUxRX0ZPUkVBQ0hfUkNVKHZhciwgaGVhZCwgZmllbGQpICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICBmb3IgKCh2YXIpID0gYXRvbWljX3JjdV9yZWFkKCYoaGVhZCktPnRxaF9maXJzdCk7ICAgICAgICAgICAgICAgICAgIFwKKyAgICAgICAgICh2YXIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwKKyAgICAgICAgICh2YXIpID0gYXRvbWljX3JjdV9yZWFkKCYodmFyKS0+ZmllbGQudHFlX25leHQpKQorCisjZGVmaW5lIFFUQUlMUV9GT1JFQUNIX1NBRkVfUkNVKHZhciwgaGVhZCwgZmllbGQsIG5leHQpICAgICAgICAgICAgICAgICAgXAorICAgIGZvciAoKHZhcikgPSBhdG9taWNfcmN1X3JlYWQoJihoZWFkKS0+dHFoX2ZpcnN0KTsgICAgICAgICAgICAgICAgICAgIFwKKyAgICAgICAgICh2YXIpICYmICgobmV4dCkgPSBhdG9taWNfcmN1X3JlYWQoJih2YXIpLT5maWVsZC50cWVfbmV4dCksIDEpOyBcCisgICAgICAgICAodmFyKSA9IChuZXh0KSkKKworI2lmZGVmIF9fY3BsdXNwbHVzCit9CisjZW5kaWYKKyNlbmRpZiAvKiBRRU1VX1JDVV9RVUVVRV9IICovCmRpZmYgLS1naXQgYS9xZW11L3NvZnRtbXUvbWVtb3J5LmMgYi9xZW11L3NvZnRtbXUvbWVtb3J5LmMKaW5kZXggYjYzNDgzMDEuLjZjZjM2YTdlIDEwMDY0NAotLS0gYS9xZW11L3NvZnRtbXUvbWVtb3J5LmMKKysrIGIvcWVtdS9zb2Z0bW11L21lbW9yeS5jCkBAIC00Myw4ICs0Myw5IEBAIE1lbW9yeVJlZ2lvbiAqbWVtb3J5X21hcChzdHJ1Y3QgdWNfc3RydWN0ICp1YywgaHdhZGRyIGJlZ2luLCBzaXplX3Qgc2l6ZSwgdWludDMyCiAgICAgTWVtb3J5UmVnaW9uICpyYW0gPSBnX25ldyhNZW1vcnlSZWdpb24sIDEpOwogCiAgICAgbWVtb3J5X3JlZ2lvbl9pbml0X3JhbSh1YywgcmFtLCBzaXplLCBwZXJtcyk7Ci0gICAgaWYgKHJhbS0+YWRkciA9PSAtMSkgeworICAgIGlmIChyYW0tPmFkZHIgPT0gLTEgfHwgIXJhbS0+cmFtX2Jsb2NrKSB7CiAgICAgICAgIC8vIG91dCBvZiBtZW1vcnkKKyAgICAgICAgZ19mcmVlKHJhbSk7CiAgICAgICAgIHJldHVybiBOVUxMOwogICAgIH0KIApAQCAtNjMsOCArNjQsOSBAQCBNZW1vcnlSZWdpb24gKm1lbW9yeV9tYXBfcHRyKHN0cnVjdCB1Y19zdHJ1Y3QgKnVjLCBod2FkZHIgYmVnaW4sIHNpemVfdCBzaXplLCB1aQogCiAgICAgbWVtb3J5X3JlZ2lvbl9pbml0X3JhbV9wdHIodWMsIHJhbSwgc2l6ZSwgcHRyKTsKICAgICByYW0tPnBlcm1zID0gcGVybXM7Ci0gICAgaWYgKHJhbS0+YWRkciA9PSAtMSkgeworICAgIGlmIChyYW0tPmFkZHIgPT0gLTEgfHwgIXJhbS0+cmFtX2Jsb2NrKSB7CiAgICAgICAgIC8vIG91dCBvZiBtZW1vcnkKKyAgICAgICAgZ19mcmVlKHJhbSk7CiAgICAgICAgIHJldHVybiBOVUxMOwogICAgIH0KIApkaWZmIC0tZ2l0IGEvcWVtdS90Y2cvdGNnLmMgYi9xZW11L3RjZy90Y2cuYwppbmRleCA0OTEwYzY3Yy4uOGI5NWUwNjIgMTAwNjQ0Ci0tLSBhL3FlbXUvdGNnL3RjZy5jCisrKyBiL3FlbXUvdGNnL3RjZy5jCkBAIC0xMDcsOCArMTA3LDggQEAgc3RhdGljIHZvaWQgdGNnX291dF9sZChUQ0dDb250ZXh0ICpzLCBUQ0dUeXBlIHR5cGUsIFRDR1JlZyByZXQsIFRDR1JlZyBhcmcxLAogc3RhdGljIGJvb2wgdGNnX291dF9tb3YoVENHQ29udGV4dCAqcywgVENHVHlwZSB0eXBlLCBUQ0dSZWcgcmV0LCBUQ0dSZWcgYXJnKTsKIHN0YXRpYyB2b2lkIHRjZ19vdXRfbW92aShUQ0dDb250ZXh0ICpzLCBUQ0dUeXBlIHR5cGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgVENHUmVnIHJldCwgdGNnX3RhcmdldF9sb25nIGFyZyk7Ci1zdGF0aWMgdm9pZCB0Y2dfb3V0X29wKFRDR0NvbnRleHQgKnMsIFRDR09wY29kZSBvcGMsIGNvbnN0IFRDR0FyZyAqYXJncywKLSAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ICpjb25zdF9hcmdzKTsKK3N0YXRpYyB2b2lkIHRjZ19vdXRfb3AoVENHQ29udGV4dCAqcywgVENHT3Bjb2RlIG9wYywgY29uc3QgVENHQXJnIGFyZ3NbVENHX01BWF9PUF9BUkdTXSwKKyAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50IGNvbnN0X2FyZ3NbVENHX01BWF9PUF9BUkdTXSk7CiAjaWYgVENHX1RBUkdFVF9NQVlCRV92ZWMKIHN0YXRpYyBib29sIHRjZ19vdXRfZHVwX3ZlYyhUQ0dDb250ZXh0ICpzLCBUQ0dUeXBlIHR5cGUsIHVuc2lnbmVkIHZlY2UsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVENHUmVnIGRzdCwgVENHUmVnIHNyYyk7CmRpZmYgLS1naXQgYS90ZXN0cy91bml0L3Rlc3RfbWVtLmMgYi90ZXN0cy91bml0L3Rlc3RfbWVtLmMKaW5kZXggN2FkNTFlNWQuLmNhNTc2ZjBlIDEwMDY0NAotLS0gYS90ZXN0cy91bml0L3Rlc3RfbWVtLmMKKysrIGIvdGVzdHMvdW5pdC90ZXN0X21lbS5jCkBAIC0xNzUsNiArMTc1LDE4IEBAIHN0YXRpYyB2b2lkIHRlc3RfbWFwX3dyYXAodm9pZCkKICAgICBPSyh1Y19jbG9zZSh1YykpOwogfQogCitzdGF0aWMgdm9pZCB0ZXN0X21hcF9iaWdfbWVtb3J5KHZvaWQpCit7CisgICAgdWNfZW5naW5lICp1YzsKKworICAgIE9LKHVjX29wZW4oVUNfQVJDSF9YODYsIFVDX01PREVfNjQsICZ1YykpOworCisgICAgdWNfYXNzZXJ0X2VycihVQ19FUlJfTk9NRU0sCisgICAgICAgICAgICAgICAgICB1Y19tZW1fbWFwKHVjLCAweDAsIDB4ZmZmZmZmZmZmZmZmZjAwMCwgVUNfUFJPVF9BTEwpKTsKKworICAgIE9LKHVjX2Nsb3NlKHVjKSk7Cit9CisKIFRFU1RfTElTVCA9IHt7InRlc3RfbWFwX2NvcnJlY3QiLCB0ZXN0X21hcF9jb3JyZWN0fSwKICAgICAgICAgICAgICB7InRlc3RfbWFwX3dyYXBwaW5nIiwgdGVzdF9tYXBfd3JhcHBpbmd9LAogICAgICAgICAgICAgIHsidGVzdF9tZW1fcHJvdGVjdCIsIHRlc3RfbWVtX3Byb3RlY3R9LApAQCAtMTgzLDQgKzE5NSw1IEBAIFRFU1RfTElTVCA9IHt7InRlc3RfbWFwX2NvcnJlY3QiLCB0ZXN0X21hcF9jb3JyZWN0fSwKICAgICAgICAgICAgICB7InRlc3RfbWVtX3Byb3RlY3RfbWFwX3B0ciIsIHRlc3RfbWVtX3Byb3RlY3RfbWFwX3B0cn0sCiAgICAgICAgICAgICAgeyJ0ZXN0X21hcF9hdF90aGVfZW5kIiwgdGVzdF9tYXBfYXRfdGhlX2VuZH0sCiAgICAgICAgICAgICAgeyJ0ZXN0X21hcF93cmFwIiwgdGVzdF9tYXBfd3JhcH0sCisgICAgICAgICAgICAgeyJ0ZXN0X21hcF9iaWdfbWVtb3J5IiwgdGVzdF9tYXBfYmlnX21lbW9yeX0sCiAgICAgICAgICAgICAge05VTEwsIE5VTEx9fTsK",
      "base_commit_hash": "M2QzZGVhYzVlNmQzODYwMmI2ODljNGZlZjVkYWMwMDRmMDdhMmU2Mwo="
    },
    "env": {},
    "base_commit_hash": "3d3deac5e6d38602b689c4fef5dac004f07a2e63",
    "patch": null,
    "repo_changes": "diff --git a/CMakeLists.txt b/CMakeLists.txt\nindex d2aac10e..e4054d98 100644\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -44,7 +44,7 @@ option(BUILD_SHARED_LIBS \"Build shared instead of static library\" ${PROJECT_IS_T\n option(UNICORN_FUZZ \"Enable fuzzing\" OFF)\n option(UNICORN_BUILD_TESTS \"Build unicorn tests\" ${PROJECT_IS_TOP_LEVEL})\n option(UNICORN_INSTALL \"Enable unicorn installation\" ${PROJECT_IS_TOP_LEVEL})\n-set(UNICORN_ARCH \"x86;arm;aarch64;riscv;mips;sparc;m68k;ppc;s390x\" CACHE STRING \"Enabled unicorn architectures\")\n+set(UNICORN_ARCH \"x86;arm;aarch64;riscv;mips;sparc;m68k;s390x\" CACHE STRING \"Enabled unicorn architectures\")\n option(UNICORN_TRACER \"Trace unicorn execution\" OFF)\n \n foreach(ARCH_LOOP ${UNICORN_ARCH})\ndiff --git a/qemu/exec.c b/qemu/exec.c\nindex 59beefaf..719895a3 100644\n--- a/qemu/exec.c\n+++ b/qemu/exec.c\n@@ -42,7 +42,7 @@\n #include \"exec/ram_addr.h\"\n \n #include \"qemu/range.h\"\n-\n+#include \"qemu/rcu_queue.h\"\n #include \"uc_priv.h\"\n \n typedef struct PhysPageEntry PhysPageEntry;\n@@ -966,7 +966,7 @@ static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n \n     assert(size != 0); /* it would hand out same offset multiple times */\n \n-    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n+    if (QLIST_EMPTY_RCU(&uc->ram_list.blocks)) {\n         return 0;\n     }\n \n@@ -1043,6 +1043,8 @@ static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n         new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                 &new_block->mr->align);\n         if (!new_block->host) {\n+            // mmap fails.\n+            uc->invalid_error = UC_ERR_NOMEM;\n             // error_setg_errno(errp, errno,\n             //         \"cannot set up guest memory '%s'\",\n             //         memory_region_name(new_block->mr));\n@@ -1062,11 +1064,11 @@ static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n         }\n     }\n     if (block) {\n-        QLIST_INSERT_BEFORE(block, new_block, next);\n+        QLIST_INSERT_BEFORE_RCU(block, new_block, next);\n     } else if (last_block) {\n-        QLIST_INSERT_AFTER(last_block, new_block, next);\n+        QLIST_INSERT_AFTER_RCU(last_block, new_block, next);\n     } else { /* list is empty */\n-        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n+        QLIST_INSERT_HEAD_RCU(&uc->ram_list.blocks, new_block, next);\n     }\n     uc->ram_list.mru_block = NULL;\n \n@@ -1099,8 +1101,15 @@ RAMBlock *qemu_ram_alloc_from_ptr(struct uc_struct *uc, ram_addr_t size, void *h\n     if (host) {\n         new_block->flags |= RAM_PREALLOC;\n     }\n+\n+    uc->invalid_addr = UC_ERR_OK;\n     ram_block_add(mr->uc, new_block);\n \n+    if (uc->invalid_error != UC_ERR_OK) {\n+        g_free(new_block);\n+        return NULL;\n+    }\n+\n     return new_block;\n }\n \n@@ -1130,7 +1139,7 @@ void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n     //    ram_block_notify_remove(block->host, block->max_length);\n     //}\n \n-    QLIST_REMOVE(block, next);\n+    QLIST_REMOVE_RCU(block, next);\n     uc->ram_list.mru_block = NULL;\n     /* Write list before version */\n     //smp_wmb();\ndiff --git a/qemu/include/qemu/atomic.h b/qemu/include/qemu/atomic.h\nindex b358c95e..fe709cef 100644\n--- a/qemu/include/qemu/atomic.h\n+++ b/qemu/include/qemu/atomic.h\n@@ -115,6 +115,19 @@\n     atomic_set__nocheck(ptr, i);                      \\\n } while(0)\n \n+#define atomic_rcu_read(ptr)                          \\\n+    ({                                                \\\n+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE); \\\n+    typeof_strip_qual(*ptr) _val;                     \\\n+    atomic_rcu_read__nocheck(ptr, &_val);             \\\n+    _val;                                             \\\n+    })\n+\n+#define atomic_rcu_set(ptr, i) do {                   \\\n+    QEMU_BUILD_BUG_ON(sizeof(*ptr) > ATOMIC_REG_SIZE); \\\n+    __atomic_store_n(ptr, i, __ATOMIC_RELEASE);       \\\n+} while(0)\n+\n /* All the remaining operations are fully sequentially consistent */\n \n #define atomic_xchg__nocheck(ptr, i)    ({                  \\\n@@ -192,6 +205,46 @@\n #define atomic_read(ptr)       atomic_read__nocheck(ptr)\n #define atomic_set(ptr, i)     atomic_set__nocheck(ptr,i)\n \n+/**\n+ * atomic_rcu_read - reads a RCU-protected pointer to a local variable\n+ * into a RCU read-side critical section. The pointer can later be safely\n+ * dereferenced within the critical section.\n+ *\n+ * This ensures that the pointer copy is invariant thorough the whole critical\n+ * section.\n+ *\n+ * Inserts memory barriers on architectures that require them (currently only\n+ * Alpha) and documents which pointers are protected by RCU.\n+ *\n+ * atomic_rcu_read also includes a compiler barrier to ensure that\n+ * value-speculative optimizations (e.g. VSS: Value Speculation\n+ * Scheduling) does not perform the data read before the pointer read\n+ * by speculating the value of the pointer.\n+ *\n+ * Should match atomic_rcu_set(), atomic_xchg(), atomic_cmpxchg().\n+ */\n+#define atomic_rcu_read(ptr)    ({                \\\n+    typeof(*ptr) _val = atomic_read(ptr);         \\\n+    smp_read_barrier_depends();                   \\\n+    _val;                                         \\\n+})\n+\n+/**\n+ * atomic_rcu_set - assigns (publicizes) a pointer to a new data structure\n+ * meant to be read by RCU read-side critical sections.\n+ *\n+ * Documents which pointers will be dereferenced by RCU read-side critical\n+ * sections and adds the required memory barriers on architectures requiring\n+ * them. It also makes sure the compiler does not reorder code initializing the\n+ * data structure before its publication.\n+ *\n+ * Should match atomic_rcu_read().\n+ */\n+#define atomic_rcu_set(ptr, i)  do {              \\\n+    smp_wmb();                                    \\\n+    atomic_set(ptr, i);                           \\\n+} while (0)\n+\n #define atomic_xchg__nocheck  atomic_xchg\n \n /* Provide shorter names for GCC atomic builtins.  */\ndiff --git a/qemu/include/qemu/rcu_queue.h b/qemu/include/qemu/rcu_queue.h\nnew file mode 100644\nindex 00000000..2d386f30\n--- /dev/null\n+++ b/qemu/include/qemu/rcu_queue.h\n@@ -0,0 +1,268 @@\n+#ifndef QEMU_RCU_QUEUE_H\n+#define QEMU_RCU_QUEUE_H\n+\n+/*\n+ * rcu_queue.h\n+ *\n+ * RCU-friendly versions of the queue.h primitives.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2.1 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n+ *\n+ * Copyright (c) 2013 Mike D. Day, IBM Corporation.\n+ *\n+ * IBM's contributions to this file may be relicensed under LGPLv2 or later.\n+ */\n+\n+#include \"qemu/queue.h\"\n+#include \"qemu/atomic.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\n+/*\n+ * List access methods.\n+ */\n+#define QLIST_EMPTY_RCU(head) (atomic_read(&(head)->lh_first) == NULL)\n+#define QLIST_FIRST_RCU(head) (atomic_rcu_read(&(head)->lh_first))\n+#define QLIST_NEXT_RCU(elm, field) (atomic_rcu_read(&(elm)->field.le_next))\n+\n+/*\n+ * List functions.\n+ */\n+\n+\n+/*\n+ *  The difference between atomic_read/set and atomic_rcu_read/set\n+ *  is in the including of a read/write memory barrier to the volatile\n+ *  access. atomic_rcu_* macros include the memory barrier, the\n+ *  plain atomic macros do not. Therefore, it should be correct to\n+ *  issue a series of reads or writes to the same element using only\n+ *  the atomic_* macro, until the last read or write, which should be\n+ *  atomic_rcu_* to introduce a read or write memory barrier as\n+ *  appropriate.\n+ */\n+\n+/* Upon publication of the listelm->next value, list readers\n+ * will see the new node when following next pointers from\n+ * antecedent nodes, but may not see the new node when following\n+ * prev pointers from subsequent nodes until after the RCU grace\n+ * period expires.\n+ * see linux/include/rculist.h __list_add_rcu(new, prev, next)\n+ */\n+#define QLIST_INSERT_AFTER_RCU(listelm, elm, field) do {    \\\n+    (elm)->field.le_next = (listelm)->field.le_next;        \\\n+    (elm)->field.le_prev = &(listelm)->field.le_next;       \\\n+    atomic_rcu_set(&(listelm)->field.le_next, (elm));       \\\n+    if ((elm)->field.le_next != NULL) {                     \\\n+       (elm)->field.le_next->field.le_prev =                \\\n+        &(elm)->field.le_next;                              \\\n+    }                                                       \\\n+} while (/*CONSTCOND*/0)\n+\n+/* Upon publication of the listelm->prev->next value, list\n+ * readers will see the new element when following prev pointers\n+ * from subsequent elements, but may not see the new element\n+ * when following next pointers from antecedent elements\n+ * until after the RCU grace period expires.\n+ */\n+#define QLIST_INSERT_BEFORE_RCU(listelm, elm, field) do {   \\\n+    (elm)->field.le_prev = (listelm)->field.le_prev;        \\\n+    (elm)->field.le_next = (listelm);                       \\\n+    atomic_rcu_set((listelm)->field.le_prev, (elm));        \\\n+    (listelm)->field.le_prev = &(elm)->field.le_next;       \\\n+} while (/*CONSTCOND*/0)\n+\n+/* Upon publication of the head->first value, list readers\n+ * will see the new element when following the head, but may\n+ * not see the new element when following prev pointers from\n+ * subsequent elements until after the RCU grace period has\n+ * expired.\n+ */\n+#define QLIST_INSERT_HEAD_RCU(head, elm, field) do {    \\\n+    (elm)->field.le_prev = &(head)->lh_first;           \\\n+    (elm)->field.le_next = (head)->lh_first;            \\\n+    atomic_rcu_set((&(head)->lh_first), (elm));         \\\n+    if ((elm)->field.le_next != NULL) {                 \\\n+       (elm)->field.le_next->field.le_prev =            \\\n+        &(elm)->field.le_next;                          \\\n+    }                                                   \\\n+} while (/*CONSTCOND*/0)\n+\n+\n+/* prior to publication of the elm->prev->next value, some list\n+ * readers may still see the removed element when following\n+ * the antecedent's next pointer.\n+ */\n+#define QLIST_REMOVE_RCU(elm, field) do {           \\\n+    if ((elm)->field.le_next != NULL) {             \\\n+       (elm)->field.le_next->field.le_prev =        \\\n+        (elm)->field.le_prev;                       \\\n+    }                                               \\\n+    atomic_set((elm)->field.le_prev, (elm)->field.le_next); \\\n+} while (/*CONSTCOND*/0)\n+\n+/* List traversal must occur within an RCU critical section.  */\n+#define QLIST_FOREACH_RCU(var, head, field)                 \\\n+        for ((var) = atomic_rcu_read(&(head)->lh_first);    \\\n+                (var);                                      \\\n+                (var) = atomic_rcu_read(&(var)->field.le_next))\n+\n+/* List traversal must occur within an RCU critical section.  */\n+#define QLIST_FOREACH_SAFE_RCU(var, head, field, next_var)           \\\n+    for ((var) = (atomic_rcu_read(&(head)->lh_first));               \\\n+      (var) &&                                                       \\\n+          ((next_var) = atomic_rcu_read(&(var)->field.le_next), 1);  \\\n+           (var) = (next_var))\n+\n+/*\n+ * RCU simple queue\n+ */\n+\n+/* Simple queue access methods */\n+#define QSIMPLEQ_EMPTY_RCU(head)      (atomic_read(&(head)->sqh_first) == NULL)\n+#define QSIMPLEQ_FIRST_RCU(head)       atomic_rcu_read(&(head)->sqh_first)\n+#define QSIMPLEQ_NEXT_RCU(elm, field)  atomic_rcu_read(&(elm)->field.sqe_next)\n+\n+/* Simple queue functions */\n+#define QSIMPLEQ_INSERT_HEAD_RCU(head, elm, field) do {         \\\n+    (elm)->field.sqe_next = (head)->sqh_first;                  \\\n+    if ((elm)->field.sqe_next == NULL) {                        \\\n+        (head)->sqh_last = &(elm)->field.sqe_next;              \\\n+    }                                                           \\\n+    atomic_rcu_set(&(head)->sqh_first, (elm));                  \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QSIMPLEQ_INSERT_TAIL_RCU(head, elm, field) do {    \\\n+    (elm)->field.sqe_next = NULL;                          \\\n+    atomic_rcu_set((head)->sqh_last, (elm));               \\\n+    (head)->sqh_last = &(elm)->field.sqe_next;             \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QSIMPLEQ_INSERT_AFTER_RCU(head, listelm, elm, field) do {       \\\n+    (elm)->field.sqe_next = (listelm)->field.sqe_next;                  \\\n+    if ((elm)->field.sqe_next == NULL) {                                \\\n+        (head)->sqh_last = &(elm)->field.sqe_next;                      \\\n+    }                                                                   \\\n+    atomic_rcu_set(&(listelm)->field.sqe_next, (elm));                  \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QSIMPLEQ_REMOVE_HEAD_RCU(head, field) do {                     \\\n+    atomic_set(&(head)->sqh_first, (head)->sqh_first->field.sqe_next); \\\n+    if ((head)->sqh_first == NULL) {                                   \\\n+        (head)->sqh_last = &(head)->sqh_first;                         \\\n+    }                                                                  \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QSIMPLEQ_REMOVE_RCU(head, elm, type, field) do {            \\\n+    if ((head)->sqh_first == (elm)) {                               \\\n+        QSIMPLEQ_REMOVE_HEAD_RCU((head), field);                    \\\n+    } else {                                                        \\\n+        struct type *curr = (head)->sqh_first;                      \\\n+        while (curr->field.sqe_next != (elm)) {                     \\\n+            curr = curr->field.sqe_next;                            \\\n+        }                                                           \\\n+        atomic_set(&curr->field.sqe_next,                           \\\n+                   curr->field.sqe_next->field.sqe_next);           \\\n+        if (curr->field.sqe_next == NULL) {                         \\\n+            (head)->sqh_last = &(curr)->field.sqe_next;             \\\n+        }                                                           \\\n+    }                                                               \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QSIMPLEQ_FOREACH_RCU(var, head, field)                          \\\n+    for ((var) = atomic_rcu_read(&(head)->sqh_first);                   \\\n+         (var);                                                         \\\n+         (var) = atomic_rcu_read(&(var)->field.sqe_next))\n+\n+#define QSIMPLEQ_FOREACH_SAFE_RCU(var, head, field, next)                \\\n+    for ((var) = atomic_rcu_read(&(head)->sqh_first);                    \\\n+         (var) && ((next) = atomic_rcu_read(&(var)->field.sqe_next), 1); \\\n+         (var) = (next))\n+\n+/*\n+ * RCU tail queue\n+ */\n+\n+/* Tail queue access methods */\n+#define QTAILQ_EMPTY_RCU(head)      (atomic_read(&(head)->tqh_first) == NULL)\n+#define QTAILQ_FIRST_RCU(head)       atomic_rcu_read(&(head)->tqh_first)\n+#define QTAILQ_NEXT_RCU(elm, field)  atomic_rcu_read(&(elm)->field.tqe_next)\n+\n+/* Tail queue functions */\n+#define QTAILQ_INSERT_HEAD_RCU(head, elm, field) do {                   \\\n+    (elm)->field.tqe_next = (head)->tqh_first;                          \\\n+    if ((elm)->field.tqe_next != NULL) {                                \\\n+        (head)->tqh_first->field.tqe_circ.tql_prev =                    \\\n+            &(elm)->field.tqe_circ;                                     \\\n+    } else {                                                            \\\n+        (head)->tqh_circ.tql_prev = &(elm)->field.tqe_circ;             \\\n+    }                                                                   \\\n+    atomic_rcu_set(&(head)->tqh_first, (elm));                          \\\n+    (elm)->field.tqe_circ.tql_prev = &(head)->tqh_circ;                 \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QTAILQ_INSERT_TAIL_RCU(head, elm, field) do {                   \\\n+    (elm)->field.tqe_next = NULL;                                       \\\n+    (elm)->field.tqe_circ.tql_prev = (head)->tqh_circ.tql_prev;         \\\n+    atomic_rcu_set(&(head)->tqh_circ.tql_prev->tql_next, (elm));        \\\n+    (head)->tqh_circ.tql_prev = &(elm)->field.tqe_circ;                 \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QTAILQ_INSERT_AFTER_RCU(head, listelm, elm, field) do {         \\\n+    (elm)->field.tqe_next = (listelm)->field.tqe_next;                  \\\n+    if ((elm)->field.tqe_next != NULL) {                                \\\n+        (elm)->field.tqe_next->field.tqe_circ.tql_prev =                \\\n+            &(elm)->field.tqe_circ;                                     \\\n+    } else {                                                            \\\n+        (head)->tqh_circ.tql_prev = &(elm)->field.tqe_circ;             \\\n+    }                                                                   \\\n+    atomic_rcu_set(&(listelm)->field.tqe_next, (elm));                  \\\n+    (elm)->field.tqe_circ.tql_prev = &(listelm)->field.tqe_circ;        \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QTAILQ_INSERT_BEFORE_RCU(listelm, elm, field) do {                \\\n+    (elm)->field.tqe_circ.tql_prev = (listelm)->field.tqe_circ.tql_prev;  \\\n+    (elm)->field.tqe_next = (listelm);                                    \\\n+    atomic_rcu_set(&(listelm)->field.tqe_circ.tql_prev->tql_next, (elm)); \\\n+    (listelm)->field.tqe_circ.tql_prev = &(elm)->field.tqe_circ;          \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QTAILQ_REMOVE_RCU(head, elm, field) do {                        \\\n+    if (((elm)->field.tqe_next) != NULL) {                              \\\n+        (elm)->field.tqe_next->field.tqe_circ.tql_prev =                \\\n+            (elm)->field.tqe_circ.tql_prev;                             \\\n+    } else {                                                            \\\n+        (head)->tqh_circ.tql_prev = (elm)->field.tqe_circ.tql_prev;     \\\n+    }                                                                   \\\n+    atomic_set(&(elm)->field.tqe_circ.tql_prev->tql_next, (elm)->field.tqe_next); \\\n+    (elm)->field.tqe_circ.tql_prev = NULL;                              \\\n+} while (/*CONSTCOND*/0)\n+\n+#define QTAILQ_FOREACH_RCU(var, head, field)                            \\\n+    for ((var) = atomic_rcu_read(&(head)->tqh_first);                   \\\n+         (var);                                                         \\\n+         (var) = atomic_rcu_read(&(var)->field.tqe_next))\n+\n+#define QTAILQ_FOREACH_SAFE_RCU(var, head, field, next)                  \\\n+    for ((var) = atomic_rcu_read(&(head)->tqh_first);                    \\\n+         (var) && ((next) = atomic_rcu_read(&(var)->field.tqe_next), 1); \\\n+         (var) = (next))\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif /* QEMU_RCU_QUEUE_H */\ndiff --git a/qemu/softmmu/memory.c b/qemu/softmmu/memory.c\nindex b6348301..6cf36a7e 100644\n--- a/qemu/softmmu/memory.c\n+++ b/qemu/softmmu/memory.c\n@@ -43,8 +43,9 @@ MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32\n     MemoryRegion *ram = g_new(MemoryRegion, 1);\n \n     memory_region_init_ram(uc, ram, size, perms);\n-    if (ram->addr == -1) {\n+    if (ram->addr == -1 || !ram->ram_block) {\n         // out of memory\n+        g_free(ram);\n         return NULL;\n     }\n \n@@ -63,8 +64,9 @@ MemoryRegion *memory_map_ptr(struct uc_struct *uc, hwaddr begin, size_t size, ui\n \n     memory_region_init_ram_ptr(uc, ram, size, ptr);\n     ram->perms = perms;\n-    if (ram->addr == -1) {\n+    if (ram->addr == -1 || !ram->ram_block) {\n         // out of memory\n+        g_free(ram);\n         return NULL;\n     }\n \ndiff --git a/qemu/tcg/tcg.c b/qemu/tcg/tcg.c\nindex 4910c67c..8b95e062 100644\n--- a/qemu/tcg/tcg.c\n+++ b/qemu/tcg/tcg.c\n@@ -107,8 +107,8 @@ static void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1,\n static bool tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg);\n static void tcg_out_movi(TCGContext *s, TCGType type,\n                          TCGReg ret, tcg_target_long arg);\n-static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n-                       const int *const_args);\n+static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg args[TCG_MAX_OP_ARGS],\n+                       const int const_args[TCG_MAX_OP_ARGS]);\n #if TCG_TARGET_MAYBE_vec\n static bool tcg_out_dup_vec(TCGContext *s, TCGType type, unsigned vece,\n                             TCGReg dst, TCGReg src);\ndiff --git a/tests/unit/test_mem.c b/tests/unit/test_mem.c\nindex 7ad51e5d..ca576f0e 100644\n--- a/tests/unit/test_mem.c\n+++ b/tests/unit/test_mem.c\n@@ -175,6 +175,18 @@ static void test_map_wrap(void)\n     OK(uc_close(uc));\n }\n \n+static void test_map_big_memory(void)\n+{\n+    uc_engine *uc;\n+\n+    OK(uc_open(UC_ARCH_X86, UC_MODE_64, &uc));\n+\n+    uc_assert_err(UC_ERR_NOMEM,\n+                  uc_mem_map(uc, 0x0, 0xfffffffffffff000, UC_PROT_ALL));\n+\n+    OK(uc_close(uc));\n+}\n+\n TEST_LIST = {{\"test_map_correct\", test_map_correct},\n              {\"test_map_wrapping\", test_map_wrapping},\n              {\"test_mem_protect\", test_mem_protect},\n@@ -183,4 +195,5 @@ TEST_LIST = {{\"test_map_correct\", test_map_correct},\n              {\"test_mem_protect_map_ptr\", test_mem_protect_map_ptr},\n              {\"test_map_at_the_end\", test_map_at_the_end},\n              {\"test_map_wrap\", test_map_wrap},\n+             {\"test_map_big_memory\", test_map_big_memory},\n              {NULL, NULL}};\n"
  }
}